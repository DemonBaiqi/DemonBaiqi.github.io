{"meta":{"title":"Hexo","subtitle":"","description":"","author":"空腹不宜吃饭","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"电赛经验","slug":"电赛经验","date":"2020-09-08T11:10:31.710Z","updated":"2020-09-08T11:10:31.710Z","comments":true,"path":"2020/09/08/电赛经验/","link":"","permalink":"http://yoursite.com/2020/09/08/%E7%94%B5%E8%B5%9B%E7%BB%8F%E9%AA%8C/","excerpt":"","text":"电赛经验代码fdc2214.c的cap_calculate中为什么 Cap = 232021045.248/(Data_FDC); keypress()函数可以用for改进","categories":[],"tags":[]},{"title":"LeetCode/纪念第一次在LeetCode上提交代码和第一次双百","slug":"LeetCode/纪念第一次在LeetCode上提交代码和第一次双百","date":"2020-07-28T09:47:18.568Z","updated":"2020-09-19T09:22:07.854Z","comments":true,"path":"2020/07/28/LeetCode/纪念第一次在LeetCode上提交代码和第一次双百/","link":"","permalink":"http://yoursite.com/2020/07/28/LeetCode/%E7%BA%AA%E5%BF%B5%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9C%A8LeetCode%E4%B8%8A%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%92%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%8C%E7%99%BE/","excerpt":"","text":"纪念第一次在LeetCode上提交代码和第一次双百在LeetCode上提交的第一道题：删除排序数组中的重复项题目难点：尽量用最少的步骤达到目的；对比最初的状态和最后的状态，捋清楚步骤； 思路： 遍历数组，遇到的第一个不重复的数，替换掉参考位置后面的元素，将参考位置后移一位； 重复以上动作直至遍历完毕； 剩余位置置零并按要求返回有效数组长度； AC代码： 123456789101112131415161718192021//删除排序数组中的重复项//遍历数组，遇到的第一个不重复的数，替换掉初始位置后面的元素int removeDuplicates(int* nums, int numsSize) &#123; int lastNum =0,i= 0; if (numsSize == 0) return 0; else &#123; for ( i = 0; i &lt; numsSize; ++i) &#123; if (nums[lastNum] != nums[i]) &#123; nums[lastNum+1] = nums[i]; lastNum++; &#125; &#125; for (int i = lastNum+1; i &lt; numsSize; ++i) nums[i] = 0; return (lastNum + 1); &#125;&#125; 结果： 第一次双百：（就就就就就非常开心吧！写出来我又觉得我行了！！！） 二叉树的前序遍历题目难点：空间复杂度，如何尽可能的不浪费数组空间； 思路： 由于直接把代码写在主函数里太乱，且不好移植，所以多写了两个函数； 题目提供的主函数只用于输出结果，重新设计一个函数用于遍历树中的每一个节点，并读取节点的元素，写入数组； 顺序：根-&gt;左-&gt;右（递归）； AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * struct TreeNode *left; * struct TreeNode *right; * &#125;; *//** * Note: The returned array must be malloced, assume caller calls free(). *///此函数只负责输出结果int* preorderTraversal(struct TreeNode* root, int* returnSize)&#123; int n = countNode(root); int *ret=(int*)malloc(n*sizeof(int)); *returnSize=0; preorder(root,returnSize,ret); return ret;&#125;//将树中的元素写入数组（直接写在主函数里很乱）void preorder(struct TreeNode* root,int* returnSize,int* ret)&#123; if (root == NULL) return; ret[*returnSize] = root-&gt;val; (*returnSize)++; preorder(root-&gt;left, returnSize,ret); preorder(root-&gt;right, returnSize,ret);&#125;//为了不浪费数组空间，先统计有效节点个数（相当于returnSize的值）int countNode(struct TreeNode* root)&#123; if (root == NULL) return 0; int node = 1; node += countNode(root-&gt;left); node += countNode(root-&gt;right); return node;&#125; 结果： leetcode的中等题，比我想象的简单一些…… 到这里就结束啦！留个纪念~ 为什么图片传不上去……乌乌","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world/hello-world","date":"2020-07-07T06:09:25.895Z","updated":"2020-07-07T06:09:25.895Z","comments":true,"path":"2020/07/07/hello-world/hello-world/","link":"","permalink":"http://yoursite.com/2020/07/07/hello-world/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}